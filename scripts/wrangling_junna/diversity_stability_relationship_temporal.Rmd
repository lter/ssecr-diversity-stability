---
title: "diversity_stability_relationship_temporal"
output: html_document
---

```{r use the spatial method to calculate diversity-stability relationships}
library(librarian)
# Install missing packages and load needed libraries
shelf(tidyverse, googlesheets4, googledrive, readxl, lmerTest, semPlot, ggplot2, codyn, ggpubr, performance, emmeans, lme4, DHARMa)
rm(list=ls())

# source('scripts/00_functions_minimize.R')

tmp <- tempfile(fileext = ".csv")
drive_folder <- googledrive::drive_ls(googledrive::as_id("https://drive.google.com/drive/folders/1xa-ypKd_ovsRov_Ol_uvE7ZI2rCc5SSj"), type='csv')
drive_download(drive_folder[drive_folder$name == "marine_agg_dss.csv",], path = tmp, overwrite = TRUE)
mar <- read.csv(tmp)

drive_download(drive_folder[drive_folder$name == "terrestrial_agg_dss.csv",], path = tmp, overwrite = TRUE)
terr <- read.csv(tmp)

# mar <- terr

# new columns
mar$site_habitat_fine <- paste(mar$site, mar$habitat_fine, sep='_')
mar$prod_stability_log <- log(mar$prod_stability)
mar$con_stability_log <- log(mar$con_stability)
mar$prod_richness_log <- log(mar$prod_richness)
mar$con_richness_log <- log(mar$con_richness)

# z-score to get standard effect size
mar$prod_richness_zscore <- scale(mar$prod_richness)
mar$con_richness_zscore <- scale(mar$con_richness)
mar$prod_stability_zscore <- scale(mar$prod_stability)
mar$con_stability_zscore <- scale(mar$con_stability)
#
mar$prod_richness_log_zscore <- scale(mar$prod_richness_log)
mar$con_richness_log_zscore <- scale(mar$con_richness_log)
mar$prod_stability_log_zscore <- scale(mar$prod_stability_log)
mar$con_stability_log_zscore <- scale(mar$con_stability_log)


# calculate mean
mar_site_mean <- mar %>% group_by(site) %>% 
  summarise(prod_richness_zscore_site_mean = mean(prod_richness_zscore), 
            con_richness_zscore_site_mean = mean(con_richness_zscore),
            prod_stability_zscore_site_mean = mean(prod_stability_zscore), 
            con_stability_zscore_site_mean = mean(con_stability_zscore),
            prod_stability_log_zscore_site_mean = mean(prod_stability_log_zscore))

if (! "prod_richness_zscore_site_mean" %in% names(mar)) {
  mar <- mar %>% left_join(mar_site_mean, by="site")
}

# calculate deviation
mar$prod_richness_zscore_devi <- mar$prod_richness_zscore - mar$prod_richness_zscore_site_mean
mar$con_richness_zscore_devi <- mar$con_richness_zscore - mar$con_richness_zscore_site_mean
mar$prod_stability_zscore_devi <- mar$prod_stability_zscore - mar$prod_stability_zscore_site_mean
mar$con_stability_zscore_devi <- mar$con_stability_zscore - mar$con_stability_zscore_site_mean
mar$prod_stability_log_zscore_devi <- mar$prod_stability_log_zscore - mar$prod_stability_log_zscore_site_mean

# step 1: which metrics to use? and whether we need to do log transformation?
# producer and consumer richness: no log transformation
# producer stability: log transformation
# consumer stability: no log transformation

# step 2: do z-standardization to get standard effect sizes
# this is needed

# step 3: control for confounding effects
# using group mean centered path model
mod_mar_prod1 <- lmer(data = mar, prod_stability_log_zscore ~ prod_richness_zscore_devi + con_richness_zscore_devi + prod_richness_zscore_site_mean + con_richness_zscore_site_mean + (1|site_habitat_fine))
summary(mod_mar_prod1)
isSingular(mod_mar_prod1, tol = 1e-4)
# 
plot(DHARMa::simulateResiduals(mod_mar_prod1))  # ks test sig; DHARMa sig;
plot(residuals(mod_mar_prod1), predict(mod_mar_prod1))

#----
mod_mar_prod2 <- lm(data = mar, prod_stability_log_zscore_devi ~ prod_richness_zscore_devi + con_richness_zscore_devi)
summary(mod_mar_prod2)

plot(DHARMa::simulateResiduals(mod_mar_prod2))         # ks test nonsig; DHARMa sig;
plot(residuals(mod_mar_prod2), predict(mod_mar_prod2))

#-------------------marine consumer community
mod_mar_con1 <- lmer(data = mar, con_stability_log_zscore ~ prod_richness_zscore_devi + con_richness_zscore_devi + prod_richness_zscore_site_mean + con_richness_zscore_site_mean + (1|site))
summary(mod_mar_con1)
isSingular(mod_mar_con1, tol = 1e-4)
# 
plot(DHARMa::simulateResiduals(mod_mar_con1))  # ks test nonsig; DHARMa sig;
plot(residuals(mod_mar_con1), predict(mod_mar_con1))

#-------------------
mod_mar_con2 <- lm(data = mar, con_stability_zscore_devi ~ prod_richness_zscore_devi + con_richness_zscore_devi)   
summary(mod_mar_con2)
# 
plot(DHARMa::simulateResiduals(mod_mar_con2))  # outlier sig; DHARMa nonsig;
plot(residuals(mod_mar_con2), predict(mod_mar_con2))
# results are similar with the last one. 



# is producer stability correlated with consumer stability
# ggplot(data=mar, aes(x=prod_stability, y=con_stability, col=site)) +
#   geom_point() +
#   geom_smooth(method = 'lm')

# MCR data is bit weird: backreef, forereef, and fringing data are different. 


# this result is mixed: USVI no relationship; aims, mcr and gcr has positive relationship; sbc has negative relationship. 



```


```{r using the temporal method to calculate diversity and stability relationship}
library(librarian)
# Install missing packages and load needed libraries
shelf(tidyverse, googlesheets4, googledrive, readxl, lmerTest, semPlot, ggplot2, codyn, ggpubr, performance, emmeans, lme4, DHARMa, glmmTMB, brms)
rm(list=ls())

source('/Users/junnawang/courses/SSECR/Diversity_stability/scripts/00_functions_minimize.R')

tmp <- tempfile(fileext = ".csv")
drive_folder <- googledrive::drive_ls(googledrive::as_id("https://drive.google.com/drive/folders/1yT4XdK6V-6GtXYcXzW_V3HllVSumDBnx"), type='csv')

# sites: 
sites_aquatic <- c("usvi_fish", "sbc_fish", "sbc_invert", "aims", "gce", "mcr_fish", "mcr_invert")
sites_terrestrial <- c("cdr_of", "kbs", "knz")
sites <- c(sites_aquatic, sites_terrestrial)

# number of years to aggregate to calculate stability; this can be changed.
duration = 5

for (isite in 1:length(sites)) {
  
  drive_download(drive_folder[drive_folder$name == paste0(sites[isite], "_producers_wide_sub.csv"),], path = tmp, overwrite = TRUE)
  producer <- read.csv(tmp)
  
  drive_download(drive_folder[drive_folder$name == paste0(sites[isite], "_consumers_wide_sub.csv"),], path = tmp, overwrite = TRUE)
  consumer <- read.csv(tmp)
  
  years <- sort(unique(producer$year))
  
  nyears <- floor(length(years) / duration) * duration
  
  period <- data.frame(start = seq(1, nyears, by = duration), end = seq(duration, nyears, by = duration))
  # do we want to add one more row
  if (length(years) - nyears >= duration / 2) {
    period <- rbind(period, data.frame(start = length(years) - duration + 1, end = length(years)))
  }
  period$start <- years[period$start]
  period$end <- years[period$end]
  period$years <- paste(period$start, period$end, sep = "_")
  #
  for (i in 1:nrow(period)) {
    producer_period <- producer %>% filter(between(year, period$start[i], period$end[i]))
    consumer_period <- consumer %>% filter(between(year, period$start[i], period$end[i]))
    calculate_agg_stability(producer_data = producer_period, consumer_data = consumer_period, site_name=sites[isite])
    # pull the output dataframe
    agg_ds_site <- get(paste0(sites[isite], "_aggregate_dss"))
    
    if (i == 1 & isite == 1) {
      agg_ds_allsites <- data.frame(agg_ds_site, period = period$years[i])
    } else {
      agg_ds_allsites <- rbind(agg_ds_allsites, data.frame(agg_ds_site, period = period$years[i]))
    }
  }
  #
}
#
agg_ds_allsites$site_period <- paste(agg_ds_allsites$site, agg_ds_allsites$period, sep="_")
# we have 34 site_period in total

# rename plot to ensure every plot is unique across these sites
agg_ds_allsites$plot_new <- agg_ds_allsites$plot
agg_ds_allsites$plot_new[agg_ds_allsites$site != "mcr"] <- paste(agg_ds_allsites$site[agg_ds_allsites$site != "mcr"], agg_ds_allsites$plot[agg_ds_allsites$site != "mcr"], sep="_")

# Step 1: log transform producer stability and consumer stability
agg_ds_allsites$prod_stability_log <- log(agg_ds_allsites$prod_stability)
agg_ds_allsites$con_stability_log <- log(agg_ds_allsites$con_stability)

# the study site "aims", "GCE" caused this problem. 
agg_ds_aquatic <- agg_ds_allsites %>% filter(site %in% c("USVI", "sbc", "aims", "GCE", "mcr")) # "USVI", "sbc", "aims", "GCE", "mcr"
agg_ds_terrestrial <- agg_ds_allsites %>% filter(site %in% c("CDR_oldField", "KBS", "KNZ"))

agg_ds_aquatic <- agg_ds_terrestrial

# ggplot(data=agg_ds_aquatic, aes(x = prod_richness, y = prod_stability_log, col = site)) +
#   geom_point()

# get z-score of two richness and stability metrics
agg_ds_aquatic$prod_stability_zscore <- scale(agg_ds_aquatic$prod_stability)
agg_ds_aquatic$con_stability_zscore <- scale(agg_ds_aquatic$con_stability)
agg_ds_aquatic$prod_stability_log_zscore <- scale(agg_ds_aquatic$prod_stability_log)
agg_ds_aquatic$con_stability_log_zscore <- scale(agg_ds_aquatic$con_stability_log)
#
agg_ds_aquatic$prod_richness_zscore <- scale(agg_ds_aquatic$prod_richness)
agg_ds_aquatic$con_richness_zscore <- scale(agg_ds_aquatic$con_richness)
# we should not log transform richness
# agg_ds_aquatic$prod_richness_zscore <- scale(log(agg_ds_aquatic$prod_richness))
# agg_ds_aquatic$con_richness_zscore <- scale(log(agg_ds_aquatic$con_richness))


# get plot mean diversity metrics
agg_ds_aquatic_plot_mean <- agg_ds_aquatic %>% group_by(plot_new) %>% summarise(prod_richness_zscore_plot_mean = mean(prod_richness_zscore), con_richness_zscore_plot_mean = mean(con_richness_zscore))

# get site_period mean diversity metrics
agg_ds_aquatic_site_period_mean <- agg_ds_aquatic %>% group_by(site_period) %>% summarise(prod_richness_zscore_site_period_mean = mean(prod_richness_zscore), con_richness_zscore_site_period_mean = mean(con_richness_zscore))
  
# join the original table
if (!"prod_richness_zscore_plot_mean" %in% names(agg_ds_aquatic)) {
  agg_ds_aquatic <- agg_ds_aquatic %>% left_join(agg_ds_aquatic_plot_mean, by = "plot_new") %>%
  left_join(agg_ds_aquatic_site_period_mean, by = "site_period")
}

agg_ds_aquatic$prod_richness_zscore_plot_mean_devi <- agg_ds_aquatic$prod_richness_zscore - agg_ds_aquatic$prod_richness_zscore_plot_mean
agg_ds_aquatic$con_richness_zscore_plot_mean_devi <- agg_ds_aquatic$con_richness_zscore - agg_ds_aquatic$con_richness_zscore_plot_mean

# How about using other linear mixed models?

mod_aquatic_prod <- lmer(data=agg_ds_aquatic, prod_stability_log_zscore ~ prod_richness_zscore_plot_mean_devi + prod_richness_zscore_plot_mean + prod_richness_zscore_site_period_mean + con_richness_zscore_plot_mean_devi + con_richness_zscore_plot_mean + con_richness_zscore_site_period_mean + (1|plot) + (1|site_period))
summary(mod_aquatic_prod)
plot(DHARMa::simulateResiduals(mod_aquatic_prod)) # failed in KS test for aquatic ecosystems

# mod_aquatic_prod_brm <- brm(data=agg_ds_aquatic, prod_stability_log_zscore ~ prod_richness_zscore_plot_mean_devi + con_richness_zscore_plot_mean_devi + prod_richness_zscore_plot_mean + prod_richness_zscore_site_period_mean + con_richness_zscore_plot_mean + con_richness_zscore_site_period_mean + (1|plot) + (1|site_period),
#                             family = gaussian(),
#                             chains = 4, cores = 4, control = list(adapt_delta = 0.95))
# summary(mod_aquatic_prod_brm)
# 
# # Step 1: simulate posterior predictions
# y_rep <- posterior_predict(mod_aquatic_prod_brm, ndraws = 1000)  # nsamples x n_obs
# y_rep_t <- t(y_rep)
# 
# # Step 2: convert to DHARMa object
# sim <- createDHARMa(
#   simulatedResponse = y_rep_t,                 # transpose to n_obs x nsim
#   observedResponse = as.vector(agg_ds_aquatic$prod_stability_log_zscore),
#   fittedPredictedResponse = apply(y_rep_t, 1, median),
#   integerResponse = FALSE
# )
# plot(sim)
# 
# hist(apply(y_rep_t, 1, median) - as.vector(agg_ds_aquatic$prod_stability_log_zscore))


mod_aquatic_con <- lmer(data=agg_ds_aquatic, con_stability_log_zscore ~ prod_richness_zscore_plot_mean_devi + prod_richness_zscore_plot_mean + prod_richness_zscore_site_period_mean + con_richness_zscore_plot_mean_devi + con_richness_zscore_plot_mean + con_richness_zscore_site_period_mean + (1|plot) + (1|site_period))
summary(mod_aquatic_con)
plot(DHARMa::simulateResiduals(mod_aquatic_con))



# single site exploration
# ggplot(data=agg_ds_usvi, aes(x=prod_richness, y=prod_stability, col=plot)) +
#   geom_point(aes(shape = period)) +
#   geom_smooth(method = 'lm')
# 
# summary(lm(data=agg_ds_usvi, con_stability ~ prod_richness + period + con_richness))
# summary(lm(data=agg_ds_usvi, prod_stability ~ prod_richness + period + con_richness))


# producers in aquatic ecosystems have the residual issues. 




```



